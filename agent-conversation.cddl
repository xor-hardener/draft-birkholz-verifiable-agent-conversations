; =============================================================================
; Verifiable Agent Conversations - CDDL Schema
; =============================================================================
;
; draft-birkholz-verifiable-agent-conversations
; Authors: Henk Birkholz, Tobias Heldt
;
; Version: 3.0.0-draft
; Date: 2026-02-18
;
; This schema unifies two complementary perspectives:
;   - File Attribution (Birkholz): WHAT code was produced and by whom
;   - Session Records (XOR): HOW the code was produced (conversation replay)
;
; Simplification (v3 vs v2):
;   - 7 entry types → 4 (message, tool, reasoning, event)
;   - All maps extensible via `* tstr => any` (RFC 8610 §3.5.4)
;   - Removed vendor-extension ceremony (subsumed by open maps)
;   - Merged session types into single session-trace
;   - Native agent fields preserved via open maps (no data loss)
;   - See: .claude/reviews/2026-02-18/ for decision log
;
; Cross-References (for reviewers):
;   See: PR #3 draft-birkholz-verifiable-agent-conversations.md for full I-D specification
;   See: PR #4 docs/cddl-extraction-methodology.md for how this schema was derived
;   See: PR #4 docs/agent-type-mapping-table.md for vendor format coverage
;   See: PR #4 examples/DATASET_MANIFEST.md for complete dataset inventory
;   See: PR #4 examples/reasoning-artifacts/ for full derivation chain (RLM→Agent0→Quint→Council)
;
; Empirical Basis:
;   - 1,452 sessions across 5 agent implementations (ARVO-136 benchmark)
;   - 13 agent-model combinations validated against this schema
;   - Agents: Claude Code, Gemini CLI, Codex CLI, OpenCode, Cursor
;   - Dataset: ARVO-136 benchmark (see PR #2 examples/sessions/README.md)
;
; Specification References:
;   RFC 8610: Concise Data Definition Language (CDDL)
;   RFC 8949: Concise Binary Object Representation (CBOR)
;   RFC 9052: CBOR Object Signing and Encryption (COSE)
;   RFC 9334: Remote ATtestation procedureS (RATS) Architecture
;   RFC 3339: Date and Time on the Internet: Timestamps
;   draft-ietf-scitt-architecture: SCITT Architecture
;
; JSON/CBOR Dual Representation:
;   This schema supports both JSON and CBOR serialization.
;   - JSON: All keys are tstr; timestamps are RFC 3339 strings
;   - CBOR: Integer keys permitted via `* tstr => any` for compact encoding
;   - Signing envelope (Section 9) requires CBOR for COSE_Sign1
;
; Extensibility:
;   All map types include `* tstr => any` as the last entry, following the
;   extensibility idiom from RFC 8610 §3.5.4 and the COSE precedent
;   (RFC 9052 uses `* label => values` on COSE_Key and header maps).
;   Defined keys use colon syntax (implicit cut semantics), so extra
;   fields cannot shadow canonical field type constraints.
;
; =============================================================================

; =============================================================================
; ROOT RULE - MUST BE FIRST FOR CDDL TOOLING COMPATIBILITY
; =============================================================================
;
; The root rule defines what this schema validates. Multiple targets supported:
;
;   1. verifiable-agent-record: Full envelope with session + file-attribution
;   2. session-trace: Just the session conversation
;   3. [* entry]: Raw entry array (vendor-native JSONL converted to array)
;   4. signed-agent-record: COSE_Sign1 wrapped record
;
; Usage with cddl gem:
;   cddl schema.cddl validate data.json                    # validates against 'start'
;   cddl schema.cddl validate data.json verifiable-agent-record  # explicit rule
;   cddl schema.cddl g                                     # generates from 'start'
;   cddl schema.cddl g 1 entry                             # generates single entry
;   cddl schema.cddl g 1 session-trace                     # generates session-trace
;
start = verifiable-agent-record

; =============================================================================
; SECTION 1: COMMON TYPES
; =============================================================================

; Timestamp: accepts BOTH RFC 3339 strings AND epoch milliseconds.
; Evidence: Claude/Gemini/Codex use ISO 8601; OpenCode uses epoch ms.
; 5/5 vendor support with format variance (Cursor lacks timestamps entirely).
; See: PR #4 docs/agent-type-mapping-table.md Section: Timestamp Format Comparison
abstract-timestamp = tstr .regexp date-time-regexp / number
; Implementations SHOULD use RFC 3339 (tstr) for new traces.
; Implementations MUST accept epoch milliseconds (number) for interop.
; When number: milliseconds since Unix epoch (1970-01-01T00:00:00Z).

; Session identifier: UUID, SHA-256 hash, or opaque string.
; Evidence: Claude/Gemini use UUID v4, Codex UUID v7, OpenCode SHA-256,
;           Cursor lacks session ID entirely (generated by converter).
session-id = tstr
; Implementations SHOULD use UUID v7 (RFC 9562) for new implementations.

; Entry identifier: per-entry unique reference.
; Evidence: 3/5 formats have explicit IDs; Codex positional; Cursor lacks.
entry-id = tstr

; RFC 3339 date-time pattern
date-time-regexp = "([0-9]{4})-(0[1-9]|1[0-2])-(0[1-9]|[12][0-9]|3[01])T([01][0-9]|2[0-3]):([0-5][0-9]):(60|[0-5][0-9])([.][0-9]+)?(Z|[+-]([01][0-9]|2[0-3]):[0-5][0-9])"

; URI pattern (RFC 3986) — used by file-attribution only
uri-regexp = "(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?"

; =============================================================================
; SECTION 2: ROOT TYPE - VERIFIABLE AGENT RECORD
; =============================================================================

; The verifiable-agent-record is the top-level container.
; It unifies two complementary perspectives:
;   - session: the conversation (how code was produced) [PRIMARY]
;   - file-attribution: the output (what code was produced) [DERIVED]
;   - signature: cryptographic envelope (verifiability) [OPTIONAL]
;
; Rationale for this architecture:
;   Session-trace captures everything. File attribution captures a subset
;   (the file modifications). File attribution can be partially derived
;   from session entries (tool-call analysis) but not fully (content_hash,
;   conversation.url require external data). Both perspectives are valuable.
;   Neither subsumes the other.
;
verifiable-agent-record = {
    version: tstr                       ; Schema version (semver)
    id: tstr                            ; Record identifier (UUID v4/v7)
    ? created: abstract-timestamp       ; When this record was created

    ; Session record: the full conversation [PRIMARY]
    ? session: session-trace

    ; File attribution: what code was produced [DERIVED]
    ? file-attribution: file-attribution-record

    ; Version control context
    ? vcs: vcs-context

    ; The agent/tool that GENERATED this record
    ? recording-agent: recording-agent

    ; Open for extensions
    * tstr => any
}

; =============================================================================
; SECTION 3: SESSION TRACE
; =============================================================================

; A session trace captures the full conversation: entries, tool calls,
; reasoning, token usage. This is the PRIMARY recording format.
;
; Simplified from v2: interactive-session / autonomous-session merged into
; a single type. The format field is optional, not a discriminator.

session-trace = {
    ? format: tstr                      ; "interactive" / "autonomous" / vendor string
    session-id: session-id              ; 4/5 vendor support (Cursor lacks)
    ? session-start: abstract-timestamp ; 4/5 (Cursor lacks timestamps entirely)
    ? session-end: abstract-timestamp   ; 4/5 (Cursor lacks timestamps entirely)
    agent-meta: agent-meta              ; 5/5
    ? environment: environment          ; 3/5 (Gemini, Cursor lack explicit working dir)
    entries: [* entry]                  ; 5/5
    * tstr => any
}

; =============================================================================
; SECTION 4: AGENT METADATA
; =============================================================================

; Identifies the coding agent and model.
; Evidence: 4/5 formats provide model identification (Cursor lacks entirely;
;           set to "unknown" when not available).

agent-meta = {
    model-id: tstr                      ; Primary model, e.g., "claude-opus-4-5-20251101"
    model-provider: tstr                ; Primary provider, e.g., "anthropic", "google"
    ? models: [* tstr]                  ; All models used (multi-model sessions)
    ? cli-name: tstr                    ; e.g., "claude-code", "gemini-cli"
    ? cli-version: tstr                 ; Semver string (2/5 vendor support)
    * tstr => any
}

; The tool/agent that GENERATED this record.
; Renamed from v1 "tool" to avoid collision with tool-call-entry.
; v1 "tool = { name, version }" -> "recording-agent = { name, version }"
recording-agent = {
    ? name: tstr                        ; CLI/tool name
    ? version: tstr                     ; CLI/tool version
    * tstr => any
}

; =============================================================================
; SECTION 5: ENVIRONMENT
; =============================================================================

; Environment context: working directory, VCS, sandbox.

environment = {
    ? working-dir: tstr                 ; Primary working directory (3/5)
    ? vcs: vcs-context                  ; Version control context
    ? sandboxes: [* tstr]               ; Sandbox mount paths (OpenCode, Codex)
    * tstr => any
}

; VCS context: git metadata for reproducibility.
; Superset of v1 vcs (which had only type + revision).
; Added: branch, repository (from 2/4 and 1/4 formats respectively).
vcs-context = {
    ? type: tstr                        ; "git" / "jj" / "hg" / "svn"
    ? revision: tstr                    ; Commit SHA or change ID
    ? branch: tstr                      ; Branch name (2/4: Claude, Codex)
    ? repository: tstr                  ; Repository URL (1/4: Codex, but valuable)
    * tstr => any
}

; =============================================================================
; SECTION 6: ENTRY TYPES
; =============================================================================

; Entry: union of 4 types (simplified from 7 in v2).
;
; DESIGN DECISION (v3):
;   Only 4 fields are universal across all 5 agent trace formats:
;     - type (5/5), timestamp (4/5), id (3/5), content (4/5)
;   All other fields are type-specific or vendor-specific.
;   The IETF "running code" criterion requires 2+ independent
;   implementations per mandatory field. These meet that bar.
;
; v2 → v3 merges:
;   user-entry + assistant-entry     → message-entry
;   tool-call-entry + tool-result-entry → tool-entry
;   system-event-entry + vendor-entry → event-entry
;   reasoning-entry                  → reasoning-entry (unchanged)
;
; All entries support:
;   - `? children: [* entry]` for hierarchical nesting (Claude/Gemini)
;   - `* tstr => any` for native agent field passthrough (no data loss)
;
; Field optionality rationale:
;   Fields marked `?` (optional) have comments like "4/5" indicating how many
;   of the 5 reference agents natively provide that field. A field is optional
;   when at least one agent implementation cannot provide it (e.g., Cursor
;   lacks timestamps, IDs, and model identification entirely). The "N/5"
;   annotation is empirical evidence, not a normative requirement.
;   Required fields have 5/5 support or are fabricated by the converter.

entry = message-entry
      / tool-entry
      / reasoning-entry
      / event-entry

; --- Message Entry ---
; Human input (user) or agent response (assistant).
; Evidence: all 5 formats have user/assistant role messages.
message-entry = {
    type: "user" / "assistant"
    ? content: any                      ; Message text or structured content blocks.
                                        ; tstr for simple text; array of parts for
                                        ; multi-part messages (e.g., Claude interleaves
                                        ; text, tool_use, and thinking blocks).
                                        ; Optional: OpenCode message-level entries have
                                        ; no inline text; content is in child entries.
    ? timestamp: abstract-timestamp     ; Entry timestamp (4/5; Cursor lacks)
    ? id: entry-id                      ; Entry identifier (3/5)
    ? model-id: tstr                    ; Model used (4/5 on assistant; absent on user entries)
    ? stop-reason: tstr                 ; "end_turn", "tool_use", "max_tokens" (assistant only)
    ? parent-id: entry-id              ; Parent message (2/5: Claude, OpenCode)
    ? token-usage: token-usage         ; Token consumption metrics
    ? children: [* entry]              ; Nested child entries
    * tstr => any                       ; Native agent fields (passthrough)
}

; --- Tool Entry ---
; Tool invocation (tool-call) or tool output (tool-result).
;
; BRIDGE TO FILE ATTRIBUTION:
;   When type is "tool-call" and name is "Edit"/"Write"/"replace"/"apply_patch",
;   input contains file_path and change data linking to file-attribution.
;
; NOTE: name/input are always present on tool-call (5/5); output is always
; present on tool-result (4/5). They are marked optional because this merged
; type covers both directions — name/input are absent on tool-result entries,
; output is absent on tool-call entries. The schema does not enforce per-subtype
; requirements; both are optional on the union type.
tool-entry = {
    type: "tool-call" / "tool-result"
    ? call-id: tstr                     ; Links call to result (3/5)
    ? name: tstr                        ; Tool name (5/5 on tool-call; absent on tool-result)
    ? input: any                        ; Tool arguments (5/5 on tool-call; absent on tool-result)
    ? output: any                       ; Tool output (4/5 on tool-result; absent on tool-call)
    ? status: tstr                      ; "success" / "error" / "completed" (3/5 on tool-result)
    ? is-error: bool                    ; Error flag (tool-result only)
    ? timestamp: abstract-timestamp
    ? id: entry-id
    ? children: [* entry]
    * tstr => any                       ; Native agent fields (passthrough)
}

; --- Reasoning Entry ---
; Chain-of-thought, thinking, or reasoning content.
reasoning-entry = {
    type: "reasoning"
    ? content: any                      ; Plaintext reasoning or structured content.
                                        ; Empty string when only encrypted content available.
    ? encrypted: tstr                   ; Encrypted content (Codex)
    ? subject: tstr                     ; Topic label (Gemini thoughts)
    ? timestamp: abstract-timestamp
    ? id: entry-id
    ? children: [* entry]
    * tstr => any                       ; Native agent fields (passthrough)
}

; --- Event Entry ---
; System lifecycle events (session-start, token-count, etc.).
event-entry = {
    type: "system-event"
    ? event-type: tstr                  ; "session-start", "session-end", "token-count", etc.
    ? data: { * tstr => any }           ; Event-specific payload
    ? timestamp: abstract-timestamp
    ? id: entry-id
    ? children: [* entry]
    * tstr => any                       ; Native agent fields (passthrough)
}

; =============================================================================
; SECTION 7: TOKEN USAGE
; =============================================================================

; Token consumption metrics for a model response.
; Evidence: 4/5 formats track tokens (Cursor lacks entirely).
; Parsers normalize from native formats into these canonical fields.
token-usage = {
    ? input: uint                       ; Input tokens (4/5)
    ? output: uint                      ; Output tokens (4/5)
    ? cached: uint                      ; Cached input tokens (3/5)
    ? reasoning: uint                   ; Reasoning/thinking tokens (2/5)
    ? total: uint                       ; Total tokens (2/5)
    ? cost: number                      ; Dollar cost (1/5: OpenCode)
    * tstr => any                       ; Native token fields (passthrough)
}

; =============================================================================
; SECTION 8: FILE ATTRIBUTION (Birkholz Model)
; =============================================================================

; TODO: This section is specified but NOT YET VALIDATED against real data.
; No parser currently produces file-attribution-record. Implementation is
; planned — see .claude/reviews/2026-02-18/simplification-plan.md Phase 4.
;
; File attribution captures WHAT code was produced: which files were
; modified, which line ranges were changed, and who (human/AI) wrote them.
;
; This model was designed by Henk Birkholz for code provenance tracking.
; It can be PARTIALLY derived from session-trace entries by analyzing
; tool-call entries that modify files (Edit, replace, apply_patch).
;
; Fields NOT derivable from session-trace alone:
;   - content_hash: requires reading final file state after all edits
;   - conversation.url: external reference to conversation source
;   - conversation.related: external resources
;
file-attribution-record = {
    files: [* file]                     ; Array of files with attributed ranges
}

file = {
    path: tstr                          ; Relative file path from repository root
    conversations: [* conversation]     ; Conversations that contributed to this file
}

conversation = {
    ? url: tstr .regexp uri-regexp      ; URL to the conversation source
    ? contributor: contributor          ; Default contributor for ranges
    ranges: [* range]                   ; Line ranges produced by this conversation
    ? related: [* resource]             ; Related external resources
}

range = {
    start_line: uint                    ; First line (1-indexed)
    end_line: uint                      ; Last line (1-indexed, inclusive)
    ? content_hash: tstr                ; Hash of content for position-independent tracking
    ? content_hash_alg: tstr            ; Hash algorithm (default: "sha-256")
    ? contributor: contributor          ; Override contributor for this range
}

contributor = {
    type: "human" / "ai" / "mixed" / "unknown"
    ? model_id: tstr                    ; Model identifier (models.dev convention)
}

resource = {
    type: tstr
    url: tstr .regexp uri-regexp
}

; =============================================================================
; SECTION 9: SIGNING ENVELOPE (COSE_Sign1)
; =============================================================================

; COSE_Sign1 signing envelope for verifiable agent records.
; Implementation: scripts/sign-record.py (Ed25519, detached payload)
;
; Signing is independent of schema compliance. A record can be:
;   - Verifiable (signed) AND schema-conformant
;   - Verifiable (signed) but vendor-native format
;   - Schema-conformant but unsigned
;
; This satisfies goals for RATS evidence generation (RFC 9334) and
; SCITT auditability (draft-ietf-scitt-architecture), both of which
; require cryptographic signing.
;
; CBOR required for COSE_Sign1. When the payload is JSON,
; it is the UTF-8 encoded JSON bytes.
;
signed-agent-record = #6.18([          ; COSE_Sign1 tag
    protected: bstr,                    ; Protected header: alg, content-type
    unprotected: {                      ; Unprotected header: trace metadata
        ? trace-metadata-key => trace-metadata
    },
    payload: bstr / null,               ; Serialized record bytes (detached if null)
    signature: bstr                     ; Cryptographic signature
])

trace-metadata-key = 100               ; Private-use label (to be registered)

trace-metadata = {
    session-id: session-id
    agent-vendor: tstr
    trace-format: trace-format-id
    timestamp-start: abstract-timestamp
    ? timestamp-end: abstract-timestamp
    ? content-hash: tstr                ; SHA-256 hex digest of payload bytes
    ? content-hash-alg: tstr            ; Hash algorithm (default: "sha-256")
}

trace-format-id = "ietf-vac-v3.0"      ; This spec's format
               / "claude-jsonl"         ; Claude Code native JSONL
               / "gemini-json"          ; Gemini CLI single-JSON
               / "codex-jsonl"          ; Codex CLI JSONL
               / "opencode-json"        ; OpenCode concatenated JSON
               / "cursor-jsonl"         ; Cursor bare JSONL (minimal metadata)
               / tstr                   ; Future formats (extensible)

; =============================================================================
; SECTION 10: INFORMATIVE - FILE ATTRIBUTION DERIVATION ALGORITHM
; =============================================================================

; TODO: Not yet implemented. See .claude/reviews/2026-02-18/ Phase 4.
;
; INFORMATIVE: How to derive file-attribution-record from session-trace.
;
; Algorithm:
;   1. Walk session-trace.entries[] in order
;   2. For each tool-entry where type is "tool-call" and name in
;      {"Edit", "Write", "replace", "apply_patch", "edit_file", "write_file"}:
;      a. Extract file_path from input (key varies by agent)
;      b. Normalize to relative path (strip working-dir prefix)
;      c. Create/update file entry in file-attribution-record.files[]
;   3. For each matching tool-entry where type is "tool-result"
;      (linked by call-id):
;      a. If status == "success", the modification is confirmed
;      b. If native metadata.files[] exists (OpenCode), extract:
;         - relativePath -> file.path
;         - diff -> parse for line ranges
;         - additions/deletions -> range extent
;         - before/after -> compute content_hash
;   4. contributor.type = "ai" (agent-produced code)
;      contributor.model_id = agent-meta.model-id or message-entry.model-id
;   5. For multi-agent sessions:
;      contributor.model_id = per-response model-id (may differ from session)
;
; Fields NOT derivable (require external data):
;   - range.content_hash: requires reading final file state after ALL edits
;   - conversation.url: must be provided by the recording system
;   - range.start_line/end_line from Claude/Gemini: requires matching
;     old_string against the original file to find line positions
;
; This algorithm is INFORMATIVE, not NORMATIVE. Implementations MAY
; generate file-attribution-record by any means, including direct
; instrumentation of the file system.

; =============================================================================
; SECTION 11: INFORMATIVE - PASSTHROUGH FIELD EXAMPLES
; =============================================================================

; With `* tstr => any` on all entry types, native agent fields are preserved
; alongside canonical fields. The following examples show what produced entries
; look like in practice.

; Example: Claude Code assistant entry with passthrough fields
;
; {
;     "type": "assistant",                      <- canonical
;     "content": [{"type": "text", "text": "..."}],  <- canonical (native array)
;     "timestamp": "2026-02-10T17:27:14.496Z",  <- canonical
;     "id": "ad554ee9-4bf4-...",                <- canonical (from line UUID)
;     "model-id": "claude-opus-4-6",            <- canonical
;     "token-usage": {                          <- canonical (extracted from message.usage)
;         "input": 3,
;         "output": 2,
;         "cached": 15360,
;         "cache_creation_input_tokens": 5559   <- native (passthrough within token-usage)
;     },
;     "children": [                             <- canonical (tool_use blocks extracted)
;         {"type": "tool-call", "name": "Bash", "input": {...}, "call-id": "toolu_..."}
;     ],
;     "parentUuid": "7e6c5e25-...",             <- native passthrough (camelCase)
;     "isSidechain": false,                     <- native passthrough (camelCase)
;     "userType": "external",                   <- native passthrough (camelCase)
;     "requestId": "req_011CX...",              <- native passthrough (camelCase)
;     "stop_reason": null,                      <- native passthrough (snake_case)
;     "stop_sequence": null                     <- native passthrough (snake_case)
; }

; Example: OpenCode tool result with rich file metadata (passthrough)
;
; {
;     "type": "tool-result",                    <- canonical
;     "output": "Success. Updated 1 file.",     <- canonical
;     "status": "completed",                    <- canonical
;     "call-id": "call_xxKq...",                <- canonical
;     "metadata": {                             <- native passthrough (from OpenCode)
;         "diff": "@@ -80,9 +80,9 @@\n ...",
;         "files": [{                           <- rich file attribution data
;             "filePath": "/tmp/.../file.cpp",
;             "relativePath": "src/file.cpp",
;             "type": "update",
;             "diff": "...",
;             "before": "<full file content>",
;             "after": "<full file content>",
;             "additions": 4,
;             "deletions": 3
;         }]
;     }
; }

; =============================================================================
; END OF SPECIFICATION
; =============================================================================
;
; Empirical Basis:
;   This schema is derived from analysis of 5 agent implementations across
;   1,452 sessions (ARVO-136 benchmark, 13 agent-model combinations).
;   Agents: Claude Code (Anthropic), Gemini CLI (Google),
;           Codex CLI (OpenAI), OpenCode (open source, multi-provider),
;           Cursor (Anysphere).
;
;   Limitations:
;     - Evidence corpus is task-biased (CVE-fixing only)
;     - Agent versions from February 2026 (may evolve)
;     - 5 of 9+ known coding agents represented
;     - File attribution (Section 8) is not yet validated against real data
;     - Signing (Section 9) validated with Ed25519 only
;
; Changelog:
;   v3.0.0-draft: Schema simplification
;     - 7 entry types → 4 (message, tool, reasoning, event)
;     - All maps extensible via `* tstr => any` (RFC 8610 §3.5.4)
;     - Removed vendor-extension types (subsumed by open maps)
;     - Merged interactive/autonomous → single session-trace
;     - Added token-usage to message-entry
;     - Native agent fields preserved (no data loss)
;     - Signing: updated trace-format to ietf-vac-v3.0
;   v2.0.0-draft: Unified Birkholz file attribution with XOR session records
;     - New root type: verifiable-agent-record (contains both perspectives)
;     - Renamed v1 "tool" to "recording-agent" (avoids tool-call collision)
;     - Added session-trace from XOR analysis (entries, tool-calls, reasoning)
;     - Merged extension mechanism: vendor-extension with tstr/int keys
;     - Added COSE_Sign1 signing envelope
;     - Added file attribution derivation algorithm
;   v1.0.0: Original Birkholz file attribution schema
;     - agent-convo-record with files, conversations, ranges, contributors
;
